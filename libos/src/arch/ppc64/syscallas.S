/* SPDX-License-Identifier: LGPL-3.0-or-later */
/* Copyright (C) 2020 IBM Corporation */

/*
 * syscallas-ppc64.S
 *
 * This file contains the entry point of system call table in library OS.
 */

#include <libos_defs.h>
#include "asm_offsets.h"
#include "gramine_entry_api.h"

#define SAVE_GPRS(OFFSET, FRAME, R1_FIXUP)		\
	std	%r0, OFFSET+SHIM_REGS_GPR0(FRAME);	\
	addi	%r0, %r1, R1_FIXUP;			\
	std	%r0, OFFSET+SHIM_REGS_GPR1(FRAME);	\
	std	%r2, OFFSET+SHIM_REGS_GPR2(FRAME);	\
	/* r3 must be stored to GRP3 and ORIG_GPR3 */	\
	std	%r4, OFFSET+SHIM_REGS_GPR4(FRAME);	\
	std	%r5, OFFSET+SHIM_REGS_GPR5(FRAME);	\
	std	%r6, OFFSET+SHIM_REGS_GPR6(FRAME);	\
	std	%r7, OFFSET+SHIM_REGS_GPR7(FRAME);	\
	std	%r8, OFFSET+SHIM_REGS_GPR8(FRAME);	\
	std	%r9, OFFSET+SHIM_REGS_GPR9(FRAME);	\
	std	%r10, OFFSET+SHIM_REGS_GPR10(FRAME);	\
	std	%r11, OFFSET+SHIM_REGS_GPR11(FRAME);	\
	std	%r12, OFFSET+SHIM_REGS_GPR12(FRAME)

#define SAVE_NV_GPRS(OFFSET, FRAME)			\
	std	%r13, OFFSET+SHIM_REGS_GPR13(FRAME);	\
	std	%r14, OFFSET+SHIM_REGS_GPR14(FRAME);	\
	std	%r15, OFFSET+SHIM_REGS_GPR15(FRAME);	\
	std	%r16, OFFSET+SHIM_REGS_GPR16(FRAME);	\
	std	%r17, OFFSET+SHIM_REGS_GPR17(FRAME);	\
	std	%r18, OFFSET+SHIM_REGS_GPR18(FRAME);	\
	std	%r19, OFFSET+SHIM_REGS_GPR19(FRAME);	\
	std	%r20, OFFSET+SHIM_REGS_GPR20(FRAME);	\
	std	%r21, OFFSET+SHIM_REGS_GPR21(FRAME);	\
	std	%r22, OFFSET+SHIM_REGS_GPR22(FRAME);	\
	std	%r23, OFFSET+SHIM_REGS_GPR23(FRAME);	\
	std	%r24, OFFSET+SHIM_REGS_GPR24(FRAME);	\
	std	%r25, OFFSET+SHIM_REGS_GPR25(FRAME);	\
	std	%r26, OFFSET+SHIM_REGS_GPR26(FRAME);	\
	std	%r27, OFFSET+SHIM_REGS_GPR27(FRAME);	\
	std	%r28, OFFSET+SHIM_REGS_GPR28(FRAME);	\
	std	%r29, OFFSET+SHIM_REGS_GPR29(FRAME);	\
	std	%r30, OFFSET+SHIM_REGS_GPR30(FRAME);	\
	std	%r31, OFFSET+SHIM_REGS_GPR31(FRAME);

#define SAVE_SPRS(OFFSET, FRAME)			\
	mflr	%r0;					\
	std	%r0, OFFSET+SHIM_REGS_LINK(FRAME);	\
	std	%r0, OFFSET+SHIM_REGS_NIP(FRAME);	\
	mfctr	%r0;					\
	std	%r0, OFFSET+SHIM_REGS_CTR(FRAME);	\
	mfxer	%r0;					\
	std	%r0, OFFSET+SHIM_REGS_XER(FRAME);	\
	mfcr	%r0;					\
	std	%r0, OFFSET+SHIM_REGS_CCR(FRAME);	\
	/* msr, dar, dsisr cannot be read */		\
	li	%r0, 0;					\
	std	%r0, OFFSET+SHIM_REGS_MSR(FRAME);	\
	std	%r0, OFFSET+SHIM_REGS_DAR(FRAME);	\
	std	%r0, OFFSET+SHIM_REGS_DSISR(FRAME);

#define SAVE_STACK_GUARD(OFFSET, FRAME)			\
	ld	%r0, -28688(%r13);			\
	std	%r0, OFFSET+SHIM_STACK_GUARD(FRAME);

#define SAVE_VSR(REG, FRAME, OFFSET)			\
	li	%r0, OFFSET;				\
	stxvd2x	%vs##REG, FRAME, %r0;

/* Since we cannot access the MSR from user space to check which facilities
 * are enabled, it is easiest to just store the 64 vsr registers. */
/* SAVE_VSRS clobbers %f0 and %v0 */
#define SAVE_VSRS(OFFSET, FRAME)			\
	mfvrsave %r0;					\
	std	%r0, OFFSET+SHIM_REGS_VRSAVE(FRAME);	\
	SAVE_VSR(0 , FRAME, OFFSET + SHIM_REGS_VSR0)	\
	SAVE_VSR(1 , FRAME, OFFSET + SHIM_REGS_VSR1)	\
	SAVE_VSR(2 , FRAME, OFFSET + SHIM_REGS_VSR2)	\
	SAVE_VSR(3 , FRAME, OFFSET + SHIM_REGS_VSR3)	\
	SAVE_VSR(4 , FRAME, OFFSET + SHIM_REGS_VSR4)	\
	SAVE_VSR(5 , FRAME, OFFSET + SHIM_REGS_VSR5)	\
	SAVE_VSR(6 , FRAME, OFFSET + SHIM_REGS_VSR6)	\
	SAVE_VSR(7 , FRAME, OFFSET + SHIM_REGS_VSR7)	\
	SAVE_VSR(8 , FRAME, OFFSET + SHIM_REGS_VSR8)	\
	SAVE_VSR(9 , FRAME, OFFSET + SHIM_REGS_VSR9)	\
	SAVE_VSR(10, FRAME, OFFSET + SHIM_REGS_VSR10)	\
	SAVE_VSR(11, FRAME, OFFSET + SHIM_REGS_VSR11)	\
	SAVE_VSR(12, FRAME, OFFSET + SHIM_REGS_VSR12)	\
	SAVE_VSR(13, FRAME, OFFSET + SHIM_REGS_VSR13)	\
	SAVE_VSR(14, FRAME, OFFSET + SHIM_REGS_VSR14)	\
	SAVE_VSR(15, FRAME, OFFSET + SHIM_REGS_VSR15)	\
	SAVE_VSR(16, FRAME, OFFSET + SHIM_REGS_VSR16)	\
	SAVE_VSR(17, FRAME, OFFSET + SHIM_REGS_VSR17)	\
	SAVE_VSR(18, FRAME, OFFSET + SHIM_REGS_VSR18)	\
	SAVE_VSR(19, FRAME, OFFSET + SHIM_REGS_VSR19)	\
	SAVE_VSR(20, FRAME, OFFSET + SHIM_REGS_VSR20)	\
	SAVE_VSR(21, FRAME, OFFSET + SHIM_REGS_VSR21)	\
	SAVE_VSR(22, FRAME, OFFSET + SHIM_REGS_VSR22)	\
	SAVE_VSR(23, FRAME, OFFSET + SHIM_REGS_VSR23)	\
	SAVE_VSR(24, FRAME, OFFSET + SHIM_REGS_VSR24)	\
	SAVE_VSR(25, FRAME, OFFSET + SHIM_REGS_VSR25)	\
	SAVE_VSR(26, FRAME, OFFSET + SHIM_REGS_VSR26)	\
	SAVE_VSR(27, FRAME, OFFSET + SHIM_REGS_VSR27)	\
	SAVE_VSR(28, FRAME, OFFSET + SHIM_REGS_VSR28)	\
	SAVE_VSR(29, FRAME, OFFSET + SHIM_REGS_VSR29)	\
	SAVE_VSR(30, FRAME, OFFSET + SHIM_REGS_VSR30)	\
	SAVE_VSR(31, FRAME, OFFSET + SHIM_REGS_VSR31)	\
	SAVE_VSR(32, FRAME, OFFSET + SHIM_REGS_VSR32)	\
	SAVE_VSR(33, FRAME, OFFSET + SHIM_REGS_VSR33)	\
	SAVE_VSR(34, FRAME, OFFSET + SHIM_REGS_VSR34)	\
	SAVE_VSR(35, FRAME, OFFSET + SHIM_REGS_VSR35)	\
	SAVE_VSR(36, FRAME, OFFSET + SHIM_REGS_VSR36)	\
	SAVE_VSR(37, FRAME, OFFSET + SHIM_REGS_VSR37)	\
	SAVE_VSR(38, FRAME, OFFSET + SHIM_REGS_VSR38)	\
	SAVE_VSR(39, FRAME, OFFSET + SHIM_REGS_VSR39)	\
	SAVE_VSR(40, FRAME, OFFSET + SHIM_REGS_VSR40)	\
	SAVE_VSR(41, FRAME, OFFSET + SHIM_REGS_VSR41)	\
	SAVE_VSR(42, FRAME, OFFSET + SHIM_REGS_VSR42)	\
	SAVE_VSR(43, FRAME, OFFSET + SHIM_REGS_VSR43)	\
	SAVE_VSR(44, FRAME, OFFSET + SHIM_REGS_VSR44)	\
	SAVE_VSR(45, FRAME, OFFSET + SHIM_REGS_VSR45)	\
	SAVE_VSR(46, FRAME, OFFSET + SHIM_REGS_VSR46)	\
	SAVE_VSR(47, FRAME, OFFSET + SHIM_REGS_VSR47)	\
	SAVE_VSR(48, FRAME, OFFSET + SHIM_REGS_VSR48)	\
	SAVE_VSR(49, FRAME, OFFSET + SHIM_REGS_VSR49)	\
	SAVE_VSR(50, FRAME, OFFSET + SHIM_REGS_VSR50)	\
	SAVE_VSR(51, FRAME, OFFSET + SHIM_REGS_VSR51)	\
	SAVE_VSR(52, FRAME, OFFSET + SHIM_REGS_VSR52)	\
	SAVE_VSR(53, FRAME, OFFSET + SHIM_REGS_VSR53)	\
	SAVE_VSR(54, FRAME, OFFSET + SHIM_REGS_VSR54)	\
	SAVE_VSR(55, FRAME, OFFSET + SHIM_REGS_VSR55)	\
	SAVE_VSR(56, FRAME, OFFSET + SHIM_REGS_VSR56)	\
	SAVE_VSR(57, FRAME, OFFSET + SHIM_REGS_VSR57)	\
	SAVE_VSR(58, FRAME, OFFSET + SHIM_REGS_VSR58)	\
	SAVE_VSR(59, FRAME, OFFSET + SHIM_REGS_VSR59)	\
	SAVE_VSR(60, FRAME, OFFSET + SHIM_REGS_VSR60)	\
	SAVE_VSR(61, FRAME, OFFSET + SHIM_REGS_VSR61)	\
	SAVE_VSR(62, FRAME, OFFSET + SHIM_REGS_VSR62)	\
	SAVE_VSR(63, FRAME, OFFSET + SHIM_REGS_VSR63)	\
	mfvrsave %r0;					\
	std	%r0, OFFSET + SHIM_REGS_VRSAVE(FRAME);	\
	mffs	%f0;					\
	stfd	%f0, OFFSET + SHIM_REGS_FPSCR(FRAME);	\
	mfvscr	%v0;					\
	li	%r0, OFFSET + SHIM_REGS_VSCR;		\
	stvx	%v0, FRAME, %r0;

	.global libos_syscall_entry
	.type libos_syscall_entry, @function

	.global libos_syscall_table_dispatch
	.type libos_syscall_table_dispatch, @function

# We are called with syscall number in r9, syscall parameters in r3-r8
# We pass them straight through to libos_syscall_table_dispatch & pointer to cr in r10
libos_syscall_entry:
	.cfi_startproc
0:
	# In case r1 gets used prepare a stackframe
	subi	%r1, %r1, 32

	std	%r3, 0(%r1)

	# Get LibOS stack in %r3 to store Context on
	ld	%r3, -0x7000 - TCBHEAD_LIBOS_PTR_FROM_END_OFFSET(%r13)
	ld	%r3, LIBOS_TCB_OFF+LIBOS_TCB_LIBOS_STACK_OFF(%r3)
	subi	%r3, %r3, SHIM_REGS_SIZE

	SAVE_GPRS(0, %r3, 32)
	# store original %r3 in Context
	ld	%r4, 0(%r1)
	std	%r4, SHIM_REGS_GPR3(%r3)
	std	%r4, SHIM_REGS_ORIG_GPR3(%r3)

	SAVE_SPRS(0, %r3)
	# Ssave all registers since we may have to build up a signal stack
	SAVE_NV_GPRS(0, %r3)
	# Save the stack guard to support fork()
	SAVE_STACK_GUARD(0, %r3)

	# storing VSRS clobbers f0 and v0 ...
	SAVE_VSRS(0, %r3)

	addis	%r2, %r12, (.TOC. - 0b)@ha
	addi	%r2, %r2, (.TOC. - 0b)@l

	subi	%r1, %r3, 256

	# call libos_syscall_table_dispatch with context ptr in r3; this will NOT return
	b	libos_syscall_table_dispatch

	.cfi_endproc
	.size libos_syscall_entry, .-libos_syscall_entry


#define RESTORE_VSR(NUM, REG1, REG2)			\
	li		REG2, SHIM_REGS_VSR ## NUM;	\
	lxvd2x		%vs ## NUM, REG1, REG2;

#define RESTORE_VSRS(REG1, REG2)	\
	RESTORE_VSR(0, REG1, REG2)	\
	RESTORE_VSR(1, REG1, REG2)	\
	RESTORE_VSR(2, REG1, REG2)	\
	RESTORE_VSR(3, REG1, REG2)	\
	RESTORE_VSR(4, REG1, REG2)	\
	RESTORE_VSR(5, REG1, REG2)	\
	RESTORE_VSR(6, REG1, REG2)	\
	RESTORE_VSR(7, REG1, REG2)	\
	RESTORE_VSR(8, REG1, REG2)	\
	RESTORE_VSR(9, REG1, REG2)	\
	RESTORE_VSR(10, REG1, REG2)	\
	RESTORE_VSR(11, REG1, REG2)	\
	RESTORE_VSR(12, REG1, REG2)	\
	RESTORE_VSR(13, REG1, REG2)	\
	RESTORE_VSR(14, REG1, REG2)	\
	RESTORE_VSR(15, REG1, REG2)	\
	RESTORE_VSR(16, REG1, REG2)	\
	RESTORE_VSR(17, REG1, REG2)	\
	RESTORE_VSR(18, REG1, REG2)	\
	RESTORE_VSR(19, REG1, REG2)	\
	RESTORE_VSR(20, REG1, REG2)	\
	RESTORE_VSR(21, REG1, REG2)	\
	RESTORE_VSR(22, REG1, REG2)	\
	RESTORE_VSR(23, REG1, REG2)	\
	RESTORE_VSR(24, REG1, REG2)	\
	RESTORE_VSR(25, REG1, REG2)	\
	RESTORE_VSR(26, REG1, REG2)	\
	RESTORE_VSR(27, REG1, REG2)	\
	RESTORE_VSR(28, REG1, REG2)	\
	RESTORE_VSR(29, REG1, REG2)	\
	RESTORE_VSR(30, REG1, REG2)	\
	RESTORE_VSR(31, REG1, REG2)	\
	RESTORE_VSR(32, REG1, REG2)	\
	RESTORE_VSR(33, REG1, REG2)	\
	RESTORE_VSR(34, REG1, REG2)	\
	RESTORE_VSR(35, REG1, REG2)	\
	RESTORE_VSR(36, REG1, REG2)	\
	RESTORE_VSR(37, REG1, REG2)	\
	RESTORE_VSR(38, REG1, REG2)	\
	RESTORE_VSR(39, REG1, REG2)	\
	RESTORE_VSR(40, REG1, REG2)	\
	RESTORE_VSR(41, REG1, REG2)	\
	RESTORE_VSR(42, REG1, REG2)	\
	RESTORE_VSR(43, REG1, REG2)	\
	RESTORE_VSR(44, REG1, REG2)	\
	RESTORE_VSR(45, REG1, REG2)	\
	RESTORE_VSR(46, REG1, REG2)	\
	RESTORE_VSR(47, REG1, REG2)	\
	RESTORE_VSR(48, REG1, REG2)	\
	RESTORE_VSR(49, REG1, REG2)	\
	RESTORE_VSR(50, REG1, REG2)	\
	RESTORE_VSR(51, REG1, REG2)	\
	RESTORE_VSR(52, REG1, REG2)	\
	RESTORE_VSR(53, REG1, REG2)	\
	RESTORE_VSR(54, REG1, REG2)	\
	RESTORE_VSR(55, REG1, REG2)	\
	RESTORE_VSR(56, REG1, REG2)	\
	RESTORE_VSR(57, REG1, REG2)	\
	RESTORE_VSR(58, REG1, REG2)	\
	RESTORE_VSR(59, REG1, REG2)	\
	RESTORE_VSR(60, REG1, REG2)	\
	RESTORE_VSR(61, REG1, REG2)	\
	RESTORE_VSR(62, REG1, REG2)	\
	RESTORE_VSR(63, REG1, REG2)

#define RESTORE_REG(NUM, REG)	\
	ld	%r ## NUM, SHIM_REGS_GPR ## NUM(REG)

	.global libos_return_with_context
	.type libos_return_with_context, @function

libos_return_with_context:
	.cfi_startproc

	mr		%r31, %r3

	ld		%r0, SHIM_REGS_VRSAVE(%r31)
	mtvrsave	%r0

	lfd 		%f0, SHIM_REGS_FPSCR(%r31)
	mtfsf		255, %f0, 1, 0

	li		%r0, SHIM_REGS_VSCR
	lvx		%v0, %r31, %r0
	mtvscr		%v0

	RESTORE_VSRS(%r31, %r0)

	RESTORE_REG(1, %r31)
	RESTORE_REG(2, %r31)
	RESTORE_REG(3, %r31)
	RESTORE_REG(4, %r31)
	RESTORE_REG(5, %r31)
	RESTORE_REG(6, %r31)
	RESTORE_REG(7, %r31)
	RESTORE_REG(8, %r31)
	RESTORE_REG(9, %r31)
	RESTORE_REG(10, %r31)
	RESTORE_REG(11, %r31)
	RESTORE_REG(12, %r31)
	RESTORE_REG(13, %r31)
	RESTORE_REG(14, %r31)
	RESTORE_REG(15, %r31)
	RESTORE_REG(16, %r31)
	RESTORE_REG(17, %r31)
	RESTORE_REG(18, %r31)
	RESTORE_REG(19, %r31)
	RESTORE_REG(20, %r31)
	RESTORE_REG(21, %r31)
	RESTORE_REG(22, %r31)
	RESTORE_REG(23, %r31)
	RESTORE_REG(24, %r31)
	RESTORE_REG(25, %r31)
	RESTORE_REG(26, %r31)
	RESTORE_REG(27, %r31)
	RESTORE_REG(28, %r31)
	RESTORE_REG(29, %r31)
	RESTORE_REG(30, %r31)
	ld	%r0, SHIM_REGS_LINK(%r31)
	mtlr	%r0
	ld	%r0, SHIM_REGS_XER(%r31)
	mtxer	%r0
	ld	%r0, SHIM_REGS_CCR(%r31)
	mtcr	%r0
	ld	%r0, SHIM_REGS_NIP(%r31)
	mtctr	%r0
	ld	%r0, SHIM_STACK_GUARD(%r31)
	std	%r0, -28688(%r13)
	RESTORE_REG(0, %r31)
	RESTORE_REG(31, %r31)
	bctr

	.cfi_endproc
	.size libos_return_with_context, .-libos_return_with_context
