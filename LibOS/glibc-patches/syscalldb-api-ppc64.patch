---
 syscallas.S |   17 ++++++++++++++
 syscalldb.h |   69 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 86 insertions(+)

Index: glibc-2.31/syscallas.S
===================================================================
--- glibc-2.31.orig/syscallas.S
+++ glibc-2.31/syscallas.S
@@ -3,9 +3,26 @@
 .weak syscalldb
 .type syscalldb,@function
 
+#if defined(__i386__) || defined(__x86_64__)
 syscalldb:
 	.cfi_startproc
 	syscall
 	retq
 	.cfi_endproc
 	.size syscalldb,.-syscalldb
+#elif defined(__powerpc64__)
+
+syscalldb:
+	.cfi_startproc
+	std %r0, -8(%r1)
+	mflr %r0
+	std %r0, 16(%r1)
+	ld %r0, -8(%r1)
+	sc
+	ld %r0, 16(%r1)
+	mtlr %r0
+	blr
+	.cfi_endproc
+	.size syscalldb,.-syscalldb
+
+#endif
Index: glibc-2.31/syscalldb.h
===================================================================
--- glibc-2.31.orig/syscalldb.h
+++ glibc-2.31/syscalldb.h
@@ -1,10 +1,20 @@
 #ifndef _SYSCALLDB_H_
 #define _SYSCALLDB_H_
 
+#define SHIM_SYSCALLDB_OFFSET      32
+#define SHIM_SYSCALLDB_OFFSET_STR  "32"
+
+#define SHIM_REGISTER_LIBRARY_OFFSET 40
+
+#if defined(__powerpc64__)
+#define TCBHEAD_LIBOS_PTR_FROM_END_OFFSET (14 * 8)
+#endif
+
 #ifdef __ASSEMBLER__
 .weak syscalldb
 .type syscalldb, @function
 
+#if defined(__i386__) || defined(__x86_64__)
 # if defined(PSEUDO) && defined(SYSCALL_NAME) && defined(SYSCALL_SYMBOL)
 #  define SYSCALLDB                     \
     subq $128, %rsp;                    \
@@ -17,11 +27,51 @@
     callq *syscalldb@GOTPCREL(%rip)
 # endif
 
+#elif defined(__powerpc64__)
+
+/*
+ * SYSCALLDB_R9:
+ * This macro is a replacement for the 'sc' instruction.
+ * As such its register clobbering behavior is like that of a Linux syscall
+ * where the following registers are volatile: r0, r3-r8, cr0
+ * Since we are doing an API call here we may be clobbering the following
+ * registers: r0, r3-r12, lr, ctr, xer, cr0-cr1, cr5-cr7 (+some fp registers)
+ * So we have to store: r9 - r12, lr, ctr, xer, cr1, cr5-cr7
+ *
+ * We do an ABI compliant call to Graphene's syscalldb with r9 holding the
+ * syscall number (rather than r0) and registers r3-r8 holding parameters.
+ * This way we don't need to worry about the runtimer linker clobbering r0.
+ */
+/* FIXME: we may need to store more registers at a SAFE PLACE! */
+# define SYSCALLDB_R9(FRAMESIZE)                 \
+    std 0,-FRAMESIZE(1); /* save syscall nr */   \
+    mflr 0;                                      \
+    std 0,16(1);         /* save lr */           \
+    ld 9,-FRAMESIZE(1);  /* restore syscall nr */\
+    stdu 1,-FRAMESIZE(1);                        \
+    /* call syscalld using tcbhead_t->LibOS */   \
+    std 2,24(1);                                 \
+    subi 12,13,0x7000+14*8;                      \
+    /* pointer to PAL_TCB in tcbhead_t */        \
+    ld 12,0(12);                                 \
+    /* our special offset in PAL_TCB for syscalldb */ \
+    ld 12,32(12);                                \
+    /* address of function must be in r12 */     \
+    mtctr 12;                                    \
+    bctrl;                                       \
+    ld 2,24(1);                                  \
+    addi 1,1,FRAMESIZE;                          \
+    ld 0,16(1);         /* restore lr */         \
+    mtlr 0;
+
+#endif /* __powerpc64 */
+
 #else /* !__ASSEMBLER__ */
 asm (
 ".weak syscalldb\r\n"
 ".type syscalldb, @function\r\n");
 
+#if defined(__i386__) || defined(__x86_64__)
 #define SYSCALLDB                           \
     "subq $128, %%rsp\n\t"                  \
     ".cfi_adjust_cfa_offset 128\n\t"        \
@@ -32,6 +82,25 @@ asm (
 #define SYSCALLDB_ASM                       \
     "callq *syscalldb@GOTPCREL(%rip)\n\t"
 
+#elif defined(__powerpc64__)
+
+static inline int register_library(const char* name, unsigned long load_address)
+{
+    typedef int(*shim_register_library_func)(const char *, unsigned long);
+    shim_register_library_func shim_register_library;
+
+    __asm__ __volatile__("subi %0,13,%1\n\t"
+                         "ld %0,0(%0)\n\t"
+                         "ld %0,%2(%0)\n\t"
+                         : "=&r" (shim_register_library)
+                         : "i" (0x7000 + TCBHEAD_LIBOS_PTR_FROM_END_OFFSET),
+                           "i" (SHIM_REGISTER_LIBRARY_OFFSET)
+                         :);
+    return shim_register_library(name, load_address);
+}
+
+#endif /* i386 || x86_64 */
+
 #endif /* Assembler */
 
 #endif /* _SYSCALLDB_H */
